<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ESP32 HTTPS Server: ESP32 HTTPS Server</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ESP32 HTTPS Server
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">ESP32 HTTPS Server </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This repository contains an HTTPS server library that can be used with the <a href="https://github.com/espressif/arduino-esp32">ESP32 Arduino Core</a>. It supports HTTP as well.</p>
<h2>Features</h2>
<ul>
<li>Make use of the built-in encryption of the ESP32 module</li>
<li>Handle multiple clients in parallel (max 3-4 SSL clients due to memory limits)</li>
<li>Usage of <code>Connection: keep-alive</code> and SSL Session reuse to reduce the overhead of SSL handshakes and speed up data transfer</li>
<li>Abstraction of handling the HTTP stuff and providing a simple API for it, eg. to access parameters, headers, HTTP Basic Auth etc.</li>
<li>Handling requests in callback functions that can be bound to URLs</li>
<li>Using middleware functions as proxy to every request to perform central tasks like authentication or logging</li>
<li>Providing support for HTTP, HTTPS or both at the same time</li>
</ul>
<h2>Dependencies</h2>
<p>The library is self-contained and just needs the Arduino and ESP32 system libraries. Running the examples requires the WiFi library in addition to that.</p>
<h2>Setup Instructions</h2>
<p>Clone or download the content of this git repository into your Arduino/libraries folder and restart your IDE.</p>
<p>To run the examples (except for the <em>Self-Signed-Certificates</em> example), you need to execute the script extras/create_cert.sh first. This script will create a simple CA to sign certificates that are used with the examples. Some notes on the usage can be found in the extras/README.md file.</p>
<p>You then should be able to add the library to your project if you selected the ESP32 as architecture.</p>
<h2>Examples</h2>
<p>You will find several examples showing how you can use the library:</p>
<ul>
<li><a href="examples/Static-Page/Static-Page.ino">Static-Page</a>: Short example showing how to serve some static resources with the server. You should start with this sketch and get familiar with it before having a look at the more complex examples.</li>
<li><a href="examples/Parameters/Parameters.ino">Parameters</a>: Shows how you can access request parameters (the part after the question mark in the URL) or parameters in dynamic URLs (like /led/1, /led/2, ...)</li>
<li><a href="examples/Put-Post-Echo/Put-Post-Echo.ino">Put-Post-Echo</a>: Implements a simple echo service for PUT and POST requests that returns the request body as response body. Also shows how to differentiate between multiple HTTP methods for the same URL.</li>
<li><a href="examples/HTTPS-and-HTTP/HTTPS-and-HTTP.ino">HTTPS-and-HTTP</a>: Shows how to serve resources via HTTP and HTTPS in parallel and how to check if the user is using a secure connection during request handling</li>
<li><a href="examples/Middleware/Middleware.ino">Middleware</a>: Shows how to use the middleware API for logging. Middleware functions are defined very similar to webservers like Express.</li>
<li><a href="examples/Authentication/Authentication.ino">Authentication</a>: Implements a chain of two middleware functions to handle authentication and authorization using HTTP Basic Auth.</li>
<li><a href="examples/Async-Server/Async-Server.ino">Async-Server</a>: Like the Static-Page example, but the server runs in a separate task on the ESP32, so you do not need to call the loop() function in your main sketch.</li>
<li><a href="examples/Websocket-Chat/Websocket-Chat.ino">Websocket-Chat</a>: Provides a browser-based chat built on top of websockets. <b>Note:</b> Websockets are still under development!</li>
<li><a href="examples/Parameter-Validation/Parameter-Validation.ino">Parameter-Validation</a>: Shows how you can integrate validator functions to do formal checks on parameters in your URL.</li>
<li><a href="examples/Self-Signed-Certificate/Self-Signed-Certificate.ino">Self-Signed-Certificate</a>: Shows how to generate a self-signed certificate on the fly on the ESP when the sketch starts. You do not need to run <code>create_cert.sh</code> to use this example.</li>
<li><a href="examples/REST-API/REST-API.ino">REST-API</a>: Uses <a href="https://arduinojson.org/">ArduinoJSON</a> and <a href="https://github.com/me-no-dev/arduino-esp32fs-plugin">SPIFFS file upload</a> to serve a small web interface that provides a REST API.</li>
</ul>
<p>If you encounter error messages that cert.h or private_key.h are missing when running an example, make sure to run create_cert.sh first (see Setup Instructions).</p>
<p>You might also want to check out the (work-in-progress) <a href="https://fhessel.github.io/esp32_https_server/">Documentation</a>.</p>
<h2>Get Started</h2>
<p>The following includes are required to be able to setup the server.</p>
<div class="fragment"><div class="line">{C++}</div><div class="line">// Inlcudes for setting up the server</div><div class="line">#include &lt;HTTPSServer.hpp&gt;</div><div class="line"></div><div class="line">// Define the certificate data for the server (Certificate and private key)</div><div class="line">#include &lt;SSLCert.hpp&gt;</div><div class="line"></div><div class="line">// Includes to define request handler callbacks</div><div class="line">#include &lt;HTTPRequest.hpp&gt;</div><div class="line">#include &lt;HTTPResponse.hpp&gt;</div><div class="line"></div><div class="line">// Required do define ResourceNodes</div><div class="line">#include &lt;ResourceNode.hpp&gt;</div><div class="line"></div><div class="line">// Easier access to the classes of the server</div><div class="line">using namespace httpsserver</div></div><!-- fragment --> <h3>Create Server Instance</h3>
<p>Then, you can create the server like this:</p>
<div class="fragment"><div class="line">{C++}</div><div class="line">// Create certificate data (see extras/README.md on how to create it)</div><div class="line">SSLCert cert = SSLCert(</div><div class="line">    crt_DER,     // DER-formatted certificate data</div><div class="line">    crt_DER_len, // length of the certificate data</div><div class="line">    key_DER,     // private key for that certificate</div><div class="line">    key_DER_len  // Length of the private key</div><div class="line">);</div><div class="line"></div><div class="line">// Setup the server with default configuration and the</div><div class="line">// certificate that has been specified before</div><div class="line">HTTPSServer myServer = HTTPSServer(cert);</div></div><!-- fragment --><p>By default, the server will listen on port 443. If you want to change that (or some other options), you can have a look at the optional parameters of the HTTPSServer constructor.</p>
<p>If you want to have just an HTTP server, you can skip the SSLCert part and replace HTTPSServer by HTTPServer. Everything else is the same for both protocols.</p>
<h3>Add Resources to the Server</h3>
<p>Every URL that should be accessible on the server has to be configured as a so-called <code>ResourceNode</code>. Such a node links a handler function to a specific URL and HTTP method. The handler function could look like this:</p>
<div class="fragment"><div class="line">{C++}</div><div class="line">void handleRoot(HTTPRequest * req, HTTPResponse * res) {</div><div class="line">    // We want to deliver an HTML page, so we set the content type</div><div class="line">    res-&gt;setHeader(&quot;Content-Type&quot;, &quot;text/html&quot;);</div><div class="line">    // The response implements the Print interface, so you can use it just like</div><div class="line">    // you would write to Serial etc.</div><div class="line">    res-&gt;println(&quot;&lt;!DOCTYPE html&gt;&quot;);</div><div class="line">    res-&gt;println(&quot;&lt;html&gt;&quot;);</div><div class="line">    res-&gt;println(&quot;&lt;head&gt;&lt;title&gt;Hello World!&lt;/title&gt;&lt;/head&gt;&quot;);</div><div class="line">    res-&gt;println(&quot;&lt;body&gt;&quot;);</div><div class="line">    res-&gt;println(&quot;&lt;h1&gt;Hello World!&lt;/h1&gt;&quot;);</div><div class="line">    res-&gt;print(&quot;&lt;p&gt;... from your ESP32!&lt;/p&gt;&quot;);</div><div class="line">    res-&gt;println(&quot;&lt;/body&gt;&quot;);</div><div class="line">    res-&gt;println(&quot;&lt;/html&gt;&quot;);</div><div class="line">}</div></div><!-- fragment --><p>As you can see, the function gets references to the HTTP request and response. You can use the request to read headers, parameters, authentication information etc. The response can be used to send data to the client, set headers or HTTP status codes.</p>
<p>Now we need to tell the server which URL should be served by this function. This can be done by creating a <code>ResourceNode</code> (usually in your <code>setup()</code> function).</p>
<div class="fragment"><div class="line">{C++}</div><div class="line">ResourceNode * nodeRoot = new ResourceNode(&quot;/&quot;, &quot;GET&quot;, &amp;handleRoot);</div></div><!-- fragment --><p>The first parameter defines the URL. It should always start with a slash, and using just a slash like here means that the function will be called for requests to the server's root (like <a href="https:/10.0.x.x/">https:/10.0.x.x/</a>).</p>
<p>The second parameter is the HTTP method, "GET" in this case.</p>
<p>Finally, you pass a reference to the request handler function to link it to the URL and method.</p>
<p>Now you just need to register the created <code>ResourceNode</code> at your server:</p>
<div class="fragment"><div class="line">{C++}</div><div class="line">myServer.registerNode(nodeRoot);</div></div><!-- fragment --><p>That's everything you need to do for a single web page on your server.</p>
<p>Note that you can define a single <code>ResourceNode</code> via <code>HTTPServer::setDefaultNode()</code>, which will be called if no other node on the server matches. Method and Path are ignored in this case. All examples use this to define a 404-handler, which might be a good idea for most scenarios.</p>
<h3>Start the Server</h3>
<p>A call to <code>HTTPServer::start()</code> will start the server so that it is listening on the port specified:</p>
<div class="fragment"><div class="line">{C++}</div><div class="line">myServer.start();</div></div><!-- fragment --><p>This code usually goes into your <code>setup()</code> function. You can use <code>HTTPServer::isRunning()</code> to check whether the server started successfully.</p>
<p>By default, you need to pass control to the server explicitly. This is done by calling the <code>HTTPServer::loop()</code> function, which you usually will put into your Arduino sketch's <code>loop()</code> function. Once called, the server will first check for incoming connection (up to the maximum connection count that has been defined in the constructor), and then handle every open connection if it has new data on the socket. So your request handler functions will be called during the call to <code>loop()</code>. Note that if one of your handler functions is blocking, it will block all other connections as well.</p>
<h3>Running the Server asynchronously</h3>
<p>If you want to have the server running in the background (and not calling <code>loop()</code> by yourself every few milliseconds), you can make use of the ESP32's task feature and put the whole server in a separate task.</p>
<p>See the Async-Server example to see how this can be done.</p>
<h2>Advanced Configuration</h2>
<p>This section covers some advanced configuration options that allow you e.g. to customize the build process, but which might require more advanced programming skills and a more sophisticated IDE that just the default Arduino IDE.</p>
<h3>Saving Space by Reducing Functionality</h3>
<p>To save program space on the microcontroller, there are some parts of the library that can be disabled during compilation and will then not be a part of your program.</p>
<p>The following flags are currently available:</p>
<table class="doxtable">
<tr>
<th>Flag </th><th>Effect  </th></tr>
<tr>
<td>HTTPS_DISABLE_SELFSIGNING </td><td>Removes the code for generating a self-signed certificate at runtime. You will need to provide certificate and private key data from another data source to use the <code>HTTPSServer</code>. </td></tr>
</table>
<p>Setting these flags requires a build environment that gives you some control of the compiler, as libraries are usually compiled separately, so just doing a <code>#define HTTPS_SOMETHING</code> in your sketch will not work.</p>
<p><b>Example: Configuration with Platform IO</b></p>
<p>To set these flags in Platform IO, you can modify your <code>platformio.ini</code>. To disable for example the self-signed-certificates part of the library, the file could look like this:</p>
<div class="fragment"><div class="line">[env:esp32dev]</div><div class="line">platform = espressif32</div><div class="line">board = esp32dev</div><div class="line">framework = arduino</div><div class="line">build_flags =</div><div class="line">  -DHTTPS_DISABLE_SELFSIGNING</div></div><!-- fragment --><p>Note the <code>-D</code> in front of the actual flag name, that passes this flag as a definition to the preprocessor. Multiple flags can be added one per line.</p>
<h3>Configure Logging</h3>
<p>The server provides some internal logging, which is used on level <code>INFO</code> by default. This will look like this on your serial console:</p>
<div class="fragment"><div class="line">[HTTPS:I] New connection. SocketFID=55</div><div class="line">[HTTPS:I] Request: GET / (FID=55)</div><div class="line">[HTTPS:I] Connection closed. Socket FID=55</div></div><!-- fragment --><p>Logging output can also be controlled by using compiler flags. This requires an advanced development environment like explained in <em>Saving Space by Reducing Functionality</em>.</p>
<p>There are two parameters that can be configured:</p>
<ul>
<li><code>HTTPS_LOGLEVEL</code> defines the log level to use</li>
<li><code>HTTPS_LOGTIMESTAMP</code> adds a timestamp (based on uptime) to each log entry</li>
</ul>
<table class="doxtable">
<tr>
<th>Value of <code>HTTPS_LOGLEVEL</code> </th><th>Error </th><th>Warning </th><th>Info </th><th>Debug  </th></tr>
<tr>
<td>0 </td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>1 </td><td>✓ </td><td></td><td></td><td></td></tr>
<tr>
<td>2 </td><td>✓ </td><td>✓ </td><td></td><td></td></tr>
<tr>
<td>3 </td><td>✓ </td><td>✓ </td><td>✓ </td><td></td></tr>
<tr>
<td>4 </td><td>✓ </td><td>✓ </td><td>✓ </td><td>✓ </td></tr>
</table>
<p><b>Example: Configuration with Platform IO</b></p>
<p>To set these flags in Platform IO, you can modify your <code>platformio.ini</code>. The following entries set the minimum log level to warning and enable timestamps</p>
<div class="fragment"><div class="line">[env:esp32dev]</div><div class="line">platform = espressif32</div><div class="line">board = esp32dev</div><div class="line">framework = arduino</div><div class="line">build_flags =</div><div class="line">  -DHTTPS_LOGLEVEL=2</div><div class="line">  -DHTTPS_LOGTIMESTAMP</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
